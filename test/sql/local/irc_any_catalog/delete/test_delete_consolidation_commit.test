# name: test/sql/local/irc_any_catalog/delete/test_delete_consolidation_commit.test
# description: test integration with iceberg catalog read
# group: [delete]

require-env ICEBERG_SERVER_AVAILABLE

require-env SECRETS_CREATED_AND_CATALOG_ATTACHED

require avro

require parquet

require iceberg

require httpfs

require core_functions

# Do not ignore 'HTTP' error messages!
set ignore_error_messages

statement ok
set enable_logging=true

statement ok
set logging_level='debug'

statement ok
drop table if exists my_datalake.default.write_v3_update_and_delete;

statement ok
create table my_datalake.default.write_v3_update_and_delete (
	id INTEGER,
	data VARCHAR
) WITH (
	'format-version' = 3
);

statement ok
begin transaction;

statement ok
insert into my_datalake.default.write_v3_update_and_delete values
	(1, 'a'),
	(2, 'b'),
	(3, 'c'),
	(4, 'd'),
	(5, 'e');

query IIII
select _last_updated_sequence_number, _row_id, id, data from my_datalake.default.write_v3_update_and_delete order by _row_id;
----
1	0	1	a
1	1	2	b
1	2	3	c
1	3	4	d
1	4	5	e

# Create the first delete on the table
statement ok
DELETE FROM my_datalake.default.write_v3_update_and_delete
WHERE id IN (2, 4);

query IIII
select _last_updated_sequence_number, _row_id, id, data from my_datalake.default.write_v3_update_and_delete order by _row_id;
----
1	0	1	a
1	2	3	c
1	4	5	e

# Create a new delete that needs to invalidate the existing delete and include its contents
statement ok
DELETE FROM my_datalake.default.write_v3_update_and_delete
WHERE id = 5;

query IIII
select _last_updated_sequence_number, _row_id, id, data from my_datalake.default.write_v3_update_and_delete order by _row_id;
----
1	0	1	a
1	2	3	c

# Create a new delete that needs to invalidate the existing delete and include its contents
statement ok
DELETE FROM my_datalake.default.write_v3_update_and_delete
WHERE id = 3;

query IIII
select _last_updated_sequence_number, _row_id, id, data from my_datalake.default.write_v3_update_and_delete order by _row_id;
----
1	0	1	a

statement ok
commit;

query IIII
select _last_updated_sequence_number, _row_id, id, data from my_datalake.default.write_v3_update_and_delete order by _row_id;
----
1	0	1	a

statement ok
set variable last_manifest_list = (
	select manifest_list from iceberg_snapshots(
		my_datalake.default.write_v3_update_and_delete
	) order by timestamp_ms desc
	offset 0 limit 1
)

# There are 3 delete manifests, because we made 3 deletes in 3 separate snapshots
query I
select count(*) from read_avro(getvariable('last_manifest_list')) where content = 1;
----
3

loop i 0 3

statement ok
set variable delete_manifest${i} = (
	select manifest_path from read_avro(
		getvariable('last_manifest_list')
	) where content = 1 order by sequence_number
	offset ${i} limit 1
);

endloop

# Count manifest_entry's that aren't status == 2 (DELETED)
query I
select count(*) from read_avro(getvariable('delete_manifest0')) where status != 2;
----
0

query I
select count(*) from read_avro(getvariable('delete_manifest1')) where status != 2;
----
0

query I
select count(*) from read_avro(getvariable('delete_manifest2')) where status != 2;
----
1
